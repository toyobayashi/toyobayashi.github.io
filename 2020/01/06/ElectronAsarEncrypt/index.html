<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://toyobayashi.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="提供一种不需要重新编译 Electron 即可完成加密 ASAR 内部代码的思路。">
<meta property="og:type" content="article">
<meta property="og:title" content="给 Electron 应用加密源码">
<meta property="og:url" content="https://toyobayashi.github.io/2020/01/06/ElectronAsarEncrypt/index.html">
<meta property="og:site_name" content="Toyo">
<meta property="og:description" content="提供一种不需要重新编译 Electron 即可完成加密 ASAR 内部代码的思路。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-01-06T15:29:15.000Z">
<meta property="article:modified_time" content="2020-06-01T07:53:40.548Z">
<meta property="article:author" content="Toyo">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://toyobayashi.github.io/2020/01/06/ElectronAsarEncrypt/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>给 Electron 应用加密源码 | Toyo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Toyo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://toyobayashi.github.io/2020/01/06/ElectronAsarEncrypt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Toyo">
      <meta itemprop="description" content="Engyo.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Toyo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          给 Electron 应用加密源码
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-06 23:29:15" itemprop="dateCreated datePublished" datetime="2020-01-06T23:29:15+08:00">2020-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-01 15:53:40" itemprop="dateModified" datetime="2020-06-01T15:53:40+08:00">2020-06-01</time>
              </span>

          
            <span id="/2020/01/06/ElectronAsarEncrypt/" class="post-meta-item leancloud_visitors" data-flag-title="给 Electron 应用加密源码" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/06/ElectronAsarEncrypt/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/06/ElectronAsarEncrypt/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>提供一种不需要重新编译 Electron 即可完成加密 ASAR 内部代码的思路。</p>
<a id="more"></a>

<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>众所周知，<a href="https://electronjs.org" target="_blank" rel="noopener">Electron</a> 官方没有提供保护源码的方法。打包一个 Electron 应用，说白了就是<a href="http://electronjs.org/docs/tutorial/application-distribution" target="_blank" rel="noopener">把源码拷到固定的一个地方</a>，比如在 Windows / Linux 下是 <code>resources/app</code> 这个目录。运行 Electron 应用时，Electron 就把这个目录当作一个 Node.js 项目去跑里面的 JS 代码。虽然 Electron 认识 ASAR 格式的代码包，即可以把所有的源码打包成一个 <code>app.asar</code> 文件放到 <code>resources</code> 目录，Electron 把 <code>app.asar</code> 当成一个文件夹，跑里面的代码，但是 ASAR 包中的文件是没有加密的，仅仅是把所有的文件拼接成了一个文件再加上了文件头信息，使用官方提供的 <code>asar</code> 库很容易把所有的源码从 ASAR 包提取出来，所以起不到加密的效果，只是对于初心者来说想接触到源码多了一点小门槛，稍微懂行一点的完全无压力。</p>
<p>所以我就在思考如何对 ASAR 包进行加密，防止商业源码被一些有心人士轻易篡改或注入一些恶意的代码后再分发。这里提供了一种不需要重新编译 Electron 即可完成加密的思路。</p>
<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p>先生成密钥保存在本地的文件中，方便 JS 打包脚本导入和 C++ include 内联。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个脚本不会被打包进客户端，本地开发用</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(path.join(__dirname, <span class="string">'src/key.txt'</span>), <span class="built_in">Array</span>.prototype.map.call(crypto.randomBytes(<span class="number">32</span>), (<span class="function"><span class="params">v</span> =&gt;</span> (<span class="string">'0x'</span> + (<span class="string">'0'</span> + v.toString(<span class="number">16</span>)).slice(<span class="number">-2</span>)))))</span><br></pre></td></tr></table></figure>

<p>这样就会在 <code>src</code> 生成一个 <code>key.txt</code> 文件，里面的内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x87,0xdb,0x34,0xc6,0x73,0xab,0xae,0xad,0x4b,0xbe,0x38,0x4b,0xf5,0xd4,0xb5,0x43,0xfe,0x65,0x1c,0xf5,0x35,0xbb,0x4a,0x78,0x0a,0x78,0x61,0x65,0x99,0x2a,0xf1,0xbb</span><br></pre></td></tr></table></figure>

<p>打包时做加密，利用 <code>asar</code> 库的 <code>asar.createPackageWithOptions()</code> 这个 API。（官方没有提供 <code>.d.ts</code> 有点烦，这里随便写一下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="node" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> asar &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPackageWithOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    src: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    dest: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    options: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="comment">// ...</span></span></span></span><br><span class="line"><span class="function"><span class="params">      transform? &lt;T <span class="keyword">extends</span> NodeJS.WritableStream&gt;(filename: <span class="built_in">string</span>): T;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Promise</span>&lt;<span class="title">void</span>&gt;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">export</span> = <span class="title">asar</span></span>;</span><br></pre></td></tr></table></figure>

<p>在第三个参数中传入 <code>transform</code> 选项，它是一个函数，返回一个转换流处理文件，返回 <code>undefined</code> 则不对文件做处理。这一步对所有的 JS 文件加密后打进 ASAR 包中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个脚本不会被打包进客户端，本地开发用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> asar = <span class="built_in">require</span>(<span class="string">'asar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取密钥，弄成一个 Buffer</span></span><br><span class="line"><span class="keyword">const</span> key = Buffer.from(fs.readFileSync(path.join(__dirname, <span class="string">'src/key.txt'</span>), <span class="string">'utf8'</span>).trim().split(<span class="string">','</span>).map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Number</span>(v.trim())))</span><br><span class="line"></span><br><span class="line">asar.createPackageWithOptions(</span><br><span class="line">  path.join(__dirname, <span class="string">'./app'</span>),</span><br><span class="line">  path.join(__dirname, <span class="string">'./test/resources/app.asar'</span>),</span><br><span class="line">  &#123;</span><br><span class="line">    unpack: <span class="string">'*.node'</span>, <span class="comment">// C++ 模块不打包</span></span><br><span class="line">    transform (filename) &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.extname(filename) === <span class="string">'.js'</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成随机的 16 字节初始化向量 IV</span></span><br><span class="line">        <span class="keyword">const</span> iv = crypto.randomBytes(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否已把 IV 拼在了加密后数据的</span></span><br><span class="line">        <span class="keyword">let</span> append = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> cipher = crypto.createCipheriv(</span><br><span class="line">          <span class="string">'aes-256-cbc'</span>,</span><br><span class="line">          key,</span><br><span class="line">          iv</span><br><span class="line">        )</span><br><span class="line">        cipher.setAutoPadding(<span class="literal">true</span>)</span><br><span class="line">        cipher.setEncoding(<span class="string">'base64'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 Readable.prototype.push 把 IV 拼在加密后数据的最前面</span></span><br><span class="line">        <span class="keyword">const</span> _p = cipher.push</span><br><span class="line">        cipher.push = <span class="function"><span class="keyword">function</span> (<span class="params">chunk, enc</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!append &amp;&amp; chunk != <span class="literal">null</span>) &#123;</span><br><span class="line">            append = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> _p.call(<span class="keyword">this</span>, Buffer.concat([iv, chunk]), enc)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _p.call(<span class="keyword">this</span>, chunk, enc)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cipher</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="主进程解密"><a href="#主进程解密" class="headerlink" title="主进程解密"></a>主进程解密</h1><p>解密在客户端运行时做，因为 V8 引擎没法运行加密后的 JS，所以必须先解密后再丢给 V8 跑。这里就有讲究了，客户端代码是可以被任何人蹂躏的，所以密钥不能明着写，也不能放配置文件，所以只能下沉到 C++ 里。用 C++ 写一个原生模块实现解密，而且这个模块不能导出解密方法，否则没有意义。另外在 C++ 源码中密钥也不能写死成字符串，因为字符串在编译后的二进制文件中是可以直接找到的。</p>
<p>什么？不导出不是没法用吗？很简单，Hack 掉 Node.js 的 API，保证外部拿不到就 OK，然后直接把这个原生模块当作入口模块，在原生模块里面再 require 一下真正的入口 JS。以下是等价的 JS 逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 C++ 写以下逻辑，可以使密钥被编译进动态库</span></span><br><span class="line"><span class="comment">// 只有反编译动态库才有可能分析出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleParent = <span class="built_in">module</span>.parent;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span> !== process.mainModule || (moduleParent !== Module &amp;&amp; moduleParent !== <span class="literal">undefined</span> &amp;&amp; moduleParent !== <span class="literal">null</span>)) &#123;</span><br><span class="line">  <span class="comment">// 如果该原生模块不是入口，就报错退出</span></span><br><span class="line">  dialog.showErrorBox(<span class="string">'Error'</span>, <span class="string">'This program has been changed by others.'</span>)</span><br><span class="line">  app.quit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, dialog &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"><span class="keyword">const</span> Module = <span class="built_in">require</span>(<span class="string">'module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKey</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在这里内联由 JS 脚本生成的密钥</span></span><br><span class="line">  <span class="comment">// const unsigned char key[32] = &#123;</span></span><br><span class="line">  <span class="comment">//   #include "key.txt"</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  <span class="keyword">return</span> KEY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span> (<span class="params">body</span>) </span>&#123; <span class="comment">// body 是 Buffer</span></span><br><span class="line">  <span class="keyword">const</span> iv = body.slice(<span class="number">0</span>, <span class="number">16</span>) <span class="comment">// 前 16 字节是 IV</span></span><br><span class="line">  <span class="keyword">const</span> data = body.slice(<span class="number">16</span>) <span class="comment">// 16 字节以后是加密后的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最好使用原生库来做解密，Node API 存在被拦截的风险</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// const clearEncoding = 'utf8' // 输出是字符串</span></span><br><span class="line">  <span class="comment">// const cipherEncoding = 'binary' // 输入是二进制</span></span><br><span class="line">  <span class="comment">// const chunks = [] // 保存分段的字符串</span></span><br><span class="line">  <span class="comment">// const decipher = crypto.createDecipheriv(</span></span><br><span class="line">  <span class="comment">//   'aes-256-cbc',</span></span><br><span class="line">  <span class="comment">//   getKey(),</span></span><br><span class="line">  <span class="comment">//   iv</span></span><br><span class="line">  <span class="comment">// )</span></span><br><span class="line">  <span class="comment">// decipher.setAutoPadding(true)</span></span><br><span class="line">  <span class="comment">// chunks.push(decipher.update(data, cipherEncoding, clearEncoding))</span></span><br><span class="line">  <span class="comment">// chunks.push(decipher.final(clearEncoding))</span></span><br><span class="line">  <span class="comment">// const code = chunks.join('')</span></span><br><span class="line">  <span class="comment">// return code</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// [native code]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oldCompile = Module.prototype._compile</span><br><span class="line"><span class="comment">// 重写 Module.prototype._compile</span></span><br><span class="line"><span class="comment">// 原因就不多写了，看下 Node 的源码就知道</span></span><br><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span> (<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (filename.indexOf(<span class="string">'app.asar'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果这个 JS 是在 app.asar 里面，就先解密</span></span><br><span class="line">    <span class="keyword">return</span> oldCompile.call(<span class="keyword">this</span>, decrypt(Buffer.from(content, <span class="string">'base64'</span>)), filename)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> oldCompile.call(<span class="keyword">this</span>, content, filename)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 主进程创建窗口在这里面，如果需要的话把密钥传给 JS，最好不要传</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./main.js'</span>)(getKey()) </span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 防止 Electron 报错后不退出</span></span><br><span class="line">  dialog.showErrorBox(<span class="string">'Error'</span>, err.stack)</span><br><span class="line">  app.quit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用 C++ 写出上面的代码，有一个问题，如何在 C++ 里拿到 JS 的 <code>require</code> 函数呢？</p>
<p>看下 Node 源码就知道，调用 <code>require</code> 就是相当于调用 <code>Module.prototype.require</code>，所以只要能拿到 <code>module</code> 对象，也就能够拿到 <code>require</code> 函数。不幸的是，NAPI 没有在模块初始化的回调中暴露 <code>module</code> 对象，有人提了 PR 但是官方似乎考虑到某些原因并不想暴露 <code>module</code>，只暴露了 <code>exports</code> 对象，不像 Node CommonJS 模块中 JS 代码被一层函数包裹：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自己写的代码在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细翻阅 Node.js 文档，可以在 process 章节里看到有 <code>global.process.mainModule</code> 这么个东西，也就是说入口模块是可以从全局拿到的，只要遍历模块的 <code>children</code> 数组往下找，对比 <code>module.exports</code> 等不等于 <code>exports</code>，就可以找到当前原生模块的 <code>module</code> 对象。</p>
<p>先封装一下运行脚本的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;napi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先封装一下脚本运行方法</span></span><br><span class="line"><span class="keyword">static</span> Napi::Value _runScript(<span class="keyword">const</span> Napi::Env&amp; env, <span class="keyword">const</span> Napi::String&amp; script) &#123;</span><br><span class="line">  napi_value res;</span><br><span class="line">  NAPI_THROW_IF_FAILED(env, napi_run_script(env, script, &amp;res), env.Undefined());</span><br><span class="line">  <span class="keyword">return</span> Napi::Value(env, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Napi::Value _runScript(<span class="keyword">const</span> Napi::Env&amp; env, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; script) &#123;</span><br><span class="line">  <span class="keyword">return</span> _runScript(env, Napi::String::New(env, script));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Napi::Value _runScript(<span class="keyword">const</span> Napi::Env&amp; env, <span class="keyword">const</span> <span class="keyword">char</span>* script) &#123;</span><br><span class="line">  <span class="keyword">return</span> _runScript(env, Napi::String::New(env, script));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以愉快地 JS in C++ 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Napi::Value _getModuleObject(<span class="keyword">const</span> Napi::Env&amp; env, <span class="keyword">const</span> Napi::Object&amp; exports) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> findModuleScript = <span class="string">"(function (exports) &#123;\n"</span></span><br><span class="line">    <span class="string">"function findModule(start, target) &#123;\n"</span></span><br><span class="line">    <span class="string">"  if (start.exports === target) &#123;\n"</span></span><br><span class="line">    <span class="string">"    return start;\n"</span></span><br><span class="line">    <span class="string">"  &#125;\n"</span></span><br><span class="line">    <span class="string">"  for (var i = 0; i &lt; start.children.length; i++) &#123;\n"</span></span><br><span class="line">    <span class="string">"    var res = findModule(start.children[i], target);\n"</span></span><br><span class="line">    <span class="string">"    if (res) &#123;\n"</span></span><br><span class="line">    <span class="string">"      return res;\n"</span></span><br><span class="line">    <span class="string">"    &#125;\n"</span></span><br><span class="line">    <span class="string">"  &#125;\n"</span></span><br><span class="line">    <span class="string">"  return null;\n"</span></span><br><span class="line">    <span class="string">"&#125;\n"</span></span><br><span class="line">    <span class="string">"return findModule(process.mainModule, exports);\n"</span></span><br><span class="line">    <span class="string">"&#125;);"</span>;</span><br><span class="line">  Napi::Function _findFunction = _runScript(env, findModuleScript).As&lt;Napi::Function&gt;();</span><br><span class="line">  Napi::Value res = _findFunction(&#123; exports &#125;);</span><br><span class="line">  <span class="keyword">if</span> (res.IsNull()) &#123;</span><br><span class="line">    Napi::Error::New(env, <span class="string">"Cannot find module object."</span>).ThrowAsJavaScriptException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Napi::Function _makeRequireFunction(<span class="keyword">const</span> Napi::Env&amp; env, <span class="keyword">const</span> Napi::Object&amp; <span class="keyword">module</span>) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> script = <span class="string">"(function makeRequireFunction(mod) &#123;\n"</span></span><br><span class="line">      <span class="string">"const Module = mod.constructor;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"function validateString (value, name) &#123; if (typeof value !== 'string') throw new TypeError('The \"' + name + '\" argument must be of type string. Received type ' + typeof value); &#125;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"const require = function require(path) &#123;\n"</span></span><br><span class="line">      <span class="string">"  return mod.require(path);\n"</span></span><br><span class="line">      <span class="string">"&#125;;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"function resolve(request, options) &#123;\n"</span></span><br><span class="line">        <span class="string">"validateString(request, 'request');\n"</span></span><br><span class="line">        <span class="string">"return Module._resolveFilename(request, mod, false, options);\n"</span></span><br><span class="line">      <span class="string">"&#125;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"require.resolve = resolve;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"function paths(request) &#123;\n"</span></span><br><span class="line">        <span class="string">"validateString(request, 'request');\n"</span></span><br><span class="line">        <span class="string">"return Module._resolveLookupPaths(request, mod);\n"</span></span><br><span class="line">      <span class="string">"&#125;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"resolve.paths = paths;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"require.main = process.mainModule;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"require.extensions = Module._extensions;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"require.cache = Module._cache;\n"</span></span><br><span class="line"></span><br><span class="line">      <span class="string">"return require;\n"</span></span><br><span class="line">    <span class="string">"&#125;);"</span>;</span><br><span class="line"></span><br><span class="line">  Napi::Function _makeRequire = _runScript(env, script).As&lt;Napi::Function&gt;();</span><br><span class="line">  <span class="keyword">return</span> _makeRequire(&#123; <span class="keyword">module</span> &#125;).As&lt;Napi::Function&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AddonData</span> &#123;</span></span><br><span class="line">  <span class="comment">// 存 Node 模块引用</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Napi::ObjectReference&gt; modules;</span><br><span class="line">  <span class="comment">// 存函数引用</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Napi::FunctionReference&gt; functions;</span><br><span class="line">&#125; AddonData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _deleteAddonData(napi_env env, <span class="keyword">void</span>* data, <span class="keyword">void</span>* hint) &#123;</span><br><span class="line">  <span class="comment">// 释放堆内存</span></span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;AddonData*&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Napi::<span class="function">Value <span class="title">modulePrototypeCompile</span><span class="params">(<span class="keyword">const</span> Napi::CallbackInfo&amp; info)</span> </span>&#123;</span><br><span class="line">  AddonData* addonData = <span class="keyword">static_cast</span>&lt;AddonData*&gt;(info.Data());</span><br><span class="line">  Napi::Function oldCompile = addonData-&gt;functions[<span class="string">"Module.prototype._compile"</span>].Value();</span><br><span class="line">  <span class="comment">// 这里推荐使用 C/C++ 的库来做解密</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Napi::Object _init(Napi::Env env, Napi::Object exports) &#123;</span><br><span class="line">  Napi::Object <span class="keyword">module</span> = _getModuleObject(env, exports).As&lt;Napi::Object&gt;();</span><br><span class="line">  Napi::Function require = _makeRequireFunction(env, <span class="keyword">module</span>);</span><br><span class="line">  <span class="comment">// const mainModule = process.mainModule</span></span><br><span class="line">  Napi::Object mainModule = env.Global().As&lt;Napi::Object&gt;().Get(<span class="string">"process"</span>).As&lt;Napi::Object&gt;().Get(<span class="string">"mainModule"</span>).As&lt;Napi::Object&gt;();</span><br><span class="line">  <span class="comment">// const electron = require('electron')</span></span><br><span class="line">  Napi::Object electron = require(&#123; Napi::String::New(env, <span class="string">"electron"</span>) &#125;).As&lt;Napi::Object&gt;();</span><br><span class="line">  <span class="comment">// require('module')</span></span><br><span class="line">  Napi::Object Module = require(&#123; Napi::String::New(env, <span class="string">"module"</span>) &#125;).As&lt;Napi::Object&gt;();</span><br><span class="line">  <span class="comment">// module.parent</span></span><br><span class="line">  Napi::Value moduleParent = <span class="keyword">module</span>.Get(<span class="string">"parent"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">module</span> != mainModule || (moduleParent != Module &amp;&amp; moduleParent != env.Undefined() &amp;&amp; moduleParent != env.Null())) &#123;</span><br><span class="line">    <span class="comment">// 入口模块不是当前的原生模块，可能会被拦截 API 导致泄露密钥</span></span><br><span class="line">    <span class="comment">// 弹窗警告后退出</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AddonData* addonData = <span class="keyword">new</span> AddonData;</span><br><span class="line">  <span class="comment">// 把 addonData 和 exports 对象关联</span></span><br><span class="line">  <span class="comment">// exports 被垃圾回收时释放 addonData 指向的内存</span></span><br><span class="line">  NAPI_THROW_IF_FAILED(env,</span><br><span class="line">    napi_wrap(env, exports, addonData, _deleteAddonData, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>),</span><br><span class="line">    exports);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// require('crypto')</span></span><br><span class="line">  <span class="comment">// addonData-&gt;modules["crypto"] = Napi::Persistent(require(&#123; Napi::String::New(env, "crypto") &#125;).As&lt;Napi::Object&gt;());</span></span><br><span class="line"></span><br><span class="line">  Napi::Object ModulePrototype = Module.Get(<span class="string">"prototype"</span>).As&lt;Napi::Object&gt;();</span><br><span class="line">  addonData-&gt;functions[<span class="string">"Module.prototype._compile"</span>] = Napi::Persistent(ModulePrototype.Get(<span class="string">"_compile"</span>).As&lt;Napi::Function&gt;());</span><br><span class="line">  ModulePrototype[<span class="string">"_compile"</span>] = Napi::Function::New(env, modulePrototypeCompile, <span class="string">"_compile"</span>, addonData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    require(&#123; Napi::String::New(env, <span class="string">"./main.js"</span>) &#125;).Call(&#123; _getKey() &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> Napi::Error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 弹窗后退出</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要分号，NODE_API_MODULE 是个宏</span></span><br><span class="line">NODE_API_MODULE(NODE_GYP_MODULE_NAME, _init)</span><br></pre></td></tr></table></figure>

<p>看到这里可能会问了搞了大半天为什么还要用 C++ 来写 JS 啊，不是明明可以 <code>_runScript()</code> 吗？ 前面也已经提到过，直接 runScript 需要把 JS 写死成字符串，在编译后的二进制文件中是原样存在的，密钥会被泄露，用 C++ 来写这些逻辑可以增加反向的难度。</p>
<p>总结下就是这样的：</p>
<ol>
<li><code>main.node</code> （已编译） 里面 require <code>main.js</code> （已加密）</li>
<li><code>main.js</code> （已加密）里面再 require 其它加密的 JS，创建窗口等等</li>
</ol>
<p>特别注意，入口必须是 main.node，如果不是，则很有可能被攻击者在加载 main.node 之前的 JS 中 hack 掉 Node API 导致密钥泄露。比如这样的入口文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> old = crypto.createDecipheriv</span><br><span class="line">crypto.createDecipheriv = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...args) <span class="comment">// 密钥被输出</span></span><br><span class="line">  <span class="keyword">return</span> old.call(crypto, ...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Module = <span class="built_in">require</span>(<span class="string">'module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oldCompile = Module.prototype._compile</span><br><span class="line">      </span><br><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span> (<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(content) <span class="comment">// JS 源码被输出</span></span><br><span class="line">  <span class="keyword">return</span> oldCompile.call(<span class="keyword">this</span>, content, filename)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.argv.length = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./main.node'</span>)</span><br><span class="line"><span class="comment">// 或 Module._load('./main.node', module, true)</span></span><br></pre></td></tr></table></figure>

<p>另外在主进程 JS 中要禁用 Node.js 调试，否则代码是可以在 Chrome 开发者工具中看到的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; process.argv.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.argv[i].indexOf(<span class="string">'--inspect'</span>) !== <span class="number">-1</span> || process.argv[i].indexOf(<span class="string">'--remote-debugging-port'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not allow debugging this program.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种方法防不住在 main.node 之前加载的脚本中设置 <code>process.argv.length = 1</code>，所以关键还是要防止入口文件被改成其它 JS 脚本。</p>
<h1 id="渲染进程解密"><a href="#渲染进程解密" class="headerlink" title="渲染进程解密"></a>渲染进程解密</h1><p>和主进程的逻辑类似，可以利用预定义宏在 C++ 中区分开主进程和渲染进程，为渲染进程再编译出一个 <code>renderer.node</code>。渲染进程加载的原生模块必须是 <code>上下文感知模块</code>，用 NAPI 写的模块已经是上下文感知的，所以没有问题，如果用 V8 的 API 去写就是不行的。</p>
<p>这里有个限制，不能在 HTML 中直接引用 <code>&lt;script&gt;</code> 标签加载 JS，因为 HTML 中的 <code>&lt;script&gt;</code> 不走 <code>Module.prototype._compile</code>，所以只能在主进程中调用 <code>browserWindow.webContents.executeJavaScript()</code> 来为每个窗口最先加载原生模块，然后再 require 其它可能需要解密的 JS 文件。</p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul>
<li>只能加密 JS，不能加密其它类型的文件，如 JSON、图片资源等</li>
<li>所有不走 <code>Module.prototype._compile</code> 的 JS 加载方法都不能加载加密后的 JS，例如依赖 HTML <code>&lt;script&gt;</code> 标签的脚本加载方式失效，Webpack 动态导入 <code>import()</code> 失效</li>
<li>如果 JS 文件很多，解密造成的性能影响较大，下面会说如何减少需要加密的 JS</li>
<li>不能使用纯 JS 实现，必须要 C++ 编译关键的密钥和解密方法</li>
<li>不能做成收费应用</li>
<li>不能算绝对安全，反编译原生模块仍然有密钥泄露和加密方法被得知的风险，只是相对于单纯的 ASAR 打包来说稍微提高了一点破解的门槛，源码不是那么容易被接触。如果有人真想蹂躏你的代码，这种方法防御力可能还远远不够</li>
</ul>
<p>最有效的方法是改 Electron 源码，重新编译 Electron。但是，动源码技术门槛高，重新编译 Electron 需要科学那什么，而且编译超慢。</p>
<h1 id="减少需要加密的-JS"><a href="#减少需要加密的-JS" class="headerlink" title="减少需要加密的 JS"></a>减少需要加密的 JS</h1><p><code>node_modules</code> 里面的 JS 很多，且不需要加密，所以可以单独抽出来一个 <code>node_modules.asar</code>，这里面的 JS 不加密。</p>
<p>如何让 <code>require</code> 找到 <code>node_modules.asar</code> 内部的库呢？答案同样是 Hack 掉 Node 的 API。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> Module = <span class="built_in">require</span>(<span class="string">'module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originalResolveLookupPaths = Module._resolveLookupPaths</span><br><span class="line"></span><br><span class="line">Module._resolveLookupPaths = originalResolveLookupPaths.length === <span class="number">2</span> ? <span class="function"><span class="keyword">function</span> (<span class="params">request, parent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Node v12+</span></span><br><span class="line">  <span class="keyword">const</span> result = originalResolveLookupPaths.call(<span class="keyword">this</span>, request, parent)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!result) <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.basename(result[i]) === <span class="string">'node_modules'</span>) &#123;</span><br><span class="line">      result.splice(i + <span class="number">1</span>, <span class="number">0</span>, result[i] + <span class="string">'.asar'</span>)</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125; : <span class="function"><span class="keyword">function</span> (<span class="params">request, parent, newReturn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Node v10-</span></span><br><span class="line">  <span class="keyword">const</span> result = originalResolveLookupPaths.call(<span class="keyword">this</span>, request, parent, newReturn)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paths = newReturn ? result : result[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.basename(paths[i]) === <span class="string">'node_modules'</span>) &#123;</span><br><span class="line">      paths.splice(i + <span class="number">1</span>, <span class="number">0</span>, paths[i] + <span class="string">'.asar'</span>)</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样把 <code>node_modules</code> 打成 <code>node_modules.asar</code> 放到 <code>resources</code> 文件夹下和 <code>app.asar</code> 同级也 OK 了。</p>
<p>注意记得 unpack <code>*.node</code> 原生模块。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>仓库：<a href="https://github.com/toyobayashi/electron-asar-encrypt-demo" target="_blank" rel="noopener">toyobayashi/electron-asar-encrypt-demo</a></p>
<p>打包时做加密，运行时做解密，解密逻辑放 C++ 里，而且必须是最先加载。</p>
<p>最后关键，不要在预加载的代码中 <code>console.log</code>，不要忘了在生产环境关掉 <code>devTools</code> 和打开 <code>nodeIntegration</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  webPreferences: &#123;</span><br><span class="line">    nodeIntegration: <span class="literal">true</span>, <span class="comment">// 渲染进程要使用 require</span></span><br><span class="line">    devTools: <span class="literal">false</span> <span class="comment">// 关掉开发者工具，因为开发者工具可以看到渲染进程的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/02/CommonJS/" rel="prev" title="从零开始实现 CommonJS">
      <i class="fa fa-chevron-left"></i> 从零开始实现 CommonJS
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/23/ApplicationList/" rel="next" title="常用应用及资源列表">
      常用应用及资源列表 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">为什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86"><span class="nav-number">2.</span> <span class="nav-text">加密</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%AF%86"><span class="nav-number">3.</span> <span class="nav-text">主进程解密</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%AF%86"><span class="nav-number">4.</span> <span class="nav-text">渲染进程解密</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">4.1.</span> <span class="nav-text">局限性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E9%9C%80%E8%A6%81%E5%8A%A0%E5%AF%86%E7%9A%84-JS"><span class="nav-number">5.</span> <span class="nav-text">减少需要加密的 JS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Toyo</p>
  <div class="site-description" itemprop="description">Engyo.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Toyo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.4.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'je6b3LE8DAXqsREbw1E0hcnr-gzGzoHsz',
      appKey: 'RqVWBpqChiOJVNyg1jSQ1chJ',
      placeholder: "请开始你的表演",
      avatar: 'retro',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
